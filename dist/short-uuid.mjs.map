{"version":3,"file":"short-uuid.mjs","sources":["../src/index.ts"],"sourcesContent":["const version = \"4.4.4\"\n\n/**\n * Types\n */\n\nexport interface Options {\n    /** User-defined character dictionary */\n    dictionary: string[] | keyof typeof DICTIONNARIES;\n\n    /** If true, sequentialUUID use the dictionary in the given order */\n    shuffle: boolean;\n\n    /** If true the instance will console.log useful info */\n    debug: boolean;\n\n    /** From 1 to infinity, the length you wish your UUID to be */\n    length: number;\n}\n\ninterface State { version: string, dict: string[], counter: number }\n\n/**\n * Constants\n */\n\nconst DEFAULT_UUID_LENGTH: number = 6;\nconst BOUNDARIES = {\n    'digits': [48, 58],\n    'alpha_lower': [97,123],\n    'hex': [97, 103],\n    'alpha_upper': [65, 91]\n}\nconst DICTIONNARIES = {\n    'number': getDictionnary([BOUNDARIES['digits']]),\n    'alpha': getDictionnary([BOUNDARIES['alpha_lower'], BOUNDARIES['alpha_upper']]),\n    'alpha_lower': getDictionnary([BOUNDARIES['alpha_lower']]),\n    'alpha_upper': getDictionnary([BOUNDARIES['alpha_upper']]),\n    'alphanum': getDictionnary([BOUNDARIES['digits'], BOUNDARIES['alpha_lower'], BOUNDARIES['alpha_upper']]),\n    'alphanum_lower': getDictionnary([BOUNDARIES['digits'], BOUNDARIES['alpha_lower']]),\n    'alphanum_upper': getDictionnary([BOUNDARIES['digits'], BOUNDARIES['alpha_upper']]),\n    'hex': getDictionnary([BOUNDARIES['digits'], BOUNDARIES['hex']])\n}\nconst DEFAULT_PROBABILITY = 0.5\n\nconst DEFAULT_OPTIONS: Options = {\n    dictionary: 'alphanum',\n    shuffle: true,\n    debug: false,\n    length: DEFAULT_UUID_LENGTH,\n}\n/**\n *\n * Utils\n *\n */\nfunction getRange(from: number, to: number): number[] {\n    return [...Array(to - from).keys()].map(i => i + from)\n}\nfunction getDictionnary(definitions: number[][]): string[] {\n    const dict: string[] = []\n    for (const [lower, upper] of definitions) {\n        getRange(lower, upper).map((bound) => {\n            dict.push(String.fromCharCode(bound))\n        })\n    }\n    return dict\n}\n\nexport const ShortUUID = (_options?: Partial<Options>) => {\n    const options = { ...DEFAULT_OPTIONS, ..._options }\n    const state: State = {\n        version: version,\n        dict: [],\n        counter: 0\n    }\n\n    const setDictionary = (dictionary: string[] | keyof typeof DICTIONNARIES, shuffle?: boolean): void => {\n        let dict: string[];\n        if (dictionary && Array.isArray(dictionary)) {\n            if (dictionary.length < 1) throw Error('Please provide an array with some elements')\n            dict = dictionary as string[];\n        } else {\n            dict = [...DICTIONNARIES[dictionary]]\n        }\n\n        if (shuffle) {\n            // Shuffle Dictionary to remove selection bias.\n            dict = dict.sort(() => Math.random() - DEFAULT_PROBABILITY)\n        }\n        state.dict = dict\n        state.counter = 0\n    }\n\n    /**\n     * Generates UUID based on internal counter that's incremented after each ID generation.\n     * @alias `const uid = new ShortUniqueId(); uid.seq();`\n     */\n    const sequentialUUID = (): string => {\n        let counterDiv: number;\n        let counterRem: number;\n        let id: string = '';\n\n        counterDiv = state.counter;\n\n        do {\n            counterRem = counterDiv % state.dict.length;\n            counterDiv = Math.trunc(counterDiv / state.dict.length);\n            id += state.dict[counterRem];\n        } while (counterDiv !== 0);\n\n        state.counter += 1;\n\n        return id;\n    };\n\n    /**\n     * Generates UUID by creating each part randomly.\n     * @alias `const uid = new ShortUniqueId(); uid(uuidLength: number);`\n     */\n    const randomUUID = (uuidLength: number = options.length || DEFAULT_UUID_LENGTH): string => {\n        if ((uuidLength === null || typeof uuidLength === 'undefined') || uuidLength < 1) {\n            throw new Error('Invalid UUID Length Provided');\n        }\n\n        // Generate random ID parts from Dictionary.\n        return getRange(0, uuidLength).map(() => {\n            const randomPartIdx = parseInt(\n                (Math.random() * state.dict.length).toFixed(0),\n                10,\n            ) % state.dict.length;\n            return state.dict[randomPartIdx];\n        }).join('')\n    };\n\n    /**\n     * Calculates total number of possible UUIDs.\n     *\n     * Given that:\n     *\n     * - `H` is the total number of possible UUIDs\n     * - `n` is the number of unique characters in the dictionary\n     * - `l` is the UUID length\n     *\n     * Then `H` is defined as `n` to the power of `l`:\n     *\n     * ![](https://render.githubusercontent.com/render/math?math=%5CHuge%20H=n%5El)\n     *\n     * This function returns `H`.\n     */\n    const availableUUIDs = (uuidLength: number = options.length): number => {\n        return parseFloat(\n            Math.pow([...new Set(state.dict)].length, uuidLength).toFixed(0),\n        );\n    };\n\n    /**\n     * Calculates approximate number of hashes before first collision.\n     *\n     * Given that:\n     *\n     * - `H` is the total number of possible UUIDs, or in terms of this library,\n     * the result of running `availableUUIDs()`\n     * - the expected number of values we have to choose before finding the\n     * first collision can be expressed as the quantity `Q(H)`\n     *\n     * Then `Q(H)` can be approximated as the square root of the product of half\n     * of pi times `H`:\n     *\n     * ![](https://render.githubusercontent.com/render/math?math=%5CHuge%20Q(H)%5Capprox%5Csqrt%7B%5Cfrac%7B%5Cpi%7D%7B2%7DH%7D)\n     *\n     * This function returns `Q(H)`.\n     *\n     * (see [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution))\n     */\n    const approxMaxBeforeCollision = (rounds: number = availableUUIDs(options.length)): number => {\n        return parseFloat(\n            Math.sqrt((Math.PI / 2) * rounds).toFixed(20),\n        );\n    };\n\n    /**\n     * Calculates probability of generating duplicate UUIDs (a collision) in a\n     * given number of UUID generation rounds.\n     *\n     * Given that:\n     *\n     * - `r` is the maximum number of times that `randomUUID()` will be called,\n     * or better said the number of _rounds_\n     * - `H` is the total number of possible UUIDs, or in terms of this library,\n     * the result of running `availableUUIDs()`\n     *\n     * Then the probability of collision `p(r; H)` can be approximated as the result\n     * of dividing the square root of the product of half of pi times `r` by `H`:\n     *\n     * ![](https://render.githubusercontent.com/render/math?math=%5CHuge%20p(r%3B%20H)%5Capprox%5Cfrac%7B%5Csqrt%7B%5Cfrac%7B%5Cpi%7D%7B2%7Dr%7D%7D%7BH%7D)\n     *\n     * This function returns `p(r; H)`.\n     *\n     * (see [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution))\n     *\n     * (Useful if you are wondering _\"If I use this lib and expect to perform at most\n     * `r` rounds of UUID generations, what is the probability that I will hit a duplicate UUID?\"_.)\n     */\n    const collisionProbability = (\n        rounds: number = availableUUIDs(options.length),\n        uuidLength: number = options.length,\n    ): number => {\n        const probability = approxMaxBeforeCollision(rounds) / availableUUIDs(uuidLength)\n        return parseFloat((probability).toFixed(20))\n    }\n\n    /**\n     * Calculate a \"uniqueness\" score (from 0 to 1) of UUIDs based on size of\n     * dictionary and chosen UUID length.\n     *\n     * Given that:\n     *\n     * - `H` is the total number of possible UUIDs, or in terms of this library,\n     * the result of running `availableUUIDs()`\n     * - `Q(H)` is the approximate number of hashes before first collision,\n     * or in terms of this library, the result of running `approxMaxBeforeCollision()`\n     *\n     * Then `uniqueness` can be expressed as the additive inverse of the probability of\n     * generating a \"word\" I had previously generated (a duplicate) at any given iteration\n     * up to the the total number of possible UUIDs expressed as the quotiend of `Q(H)` and `H`:\n     *\n     * ![](https://render.githubusercontent.com/render/math?math=%5CHuge%201-%5Cfrac%7BQ(H)%7D%7BH%7D)\n     *\n     * (Useful if you need a value to rate the \"quality\" of the combination of given dictionary\n     * and UUID length. The closer to 1, higher the uniqueness and thus better the quality.)\n     */\n    const uniqueness = (rounds: number = availableUUIDs(options.length)): number => {\n        const collisionOnRounds = approxMaxBeforeCollision(rounds) / rounds\n        const score = parseFloat((1 - collisionOnRounds).toFixed(20))\n\n        if (score > 1)\n            return 1\n        if (score < 0)\n            return 0\n        return score\n    }\n\n    /**\n     * Return the version of this module.\n     */\n    const getVersion = (): string => {\n        return state.version\n    }\n\n    /**\n     * Generates a UUID with a timestamp that can be extracted using `uid.parseStamp(stampString);`.\n     *\n     * ```js\n     *  const uidWithTimestamp = uid.stamp(32);\n     *  console.log(uidWithTimestamp);\n     *  // GDa608f973aRCHLXQYPTbKDbjDeVsSb3\n     *\n     *  console.log(uid.parseStamp(uidWithTimestamp));\n     *  // 2021-05-03T06:24:58.000Z\n     *  ```\n     */\n    const stamp = (finalLength: number): string => {\n        if (typeof finalLength !== 'number' || finalLength < 10) {\n        throw new Error('Param finalLength must be number greater than 10');\n        }\n\n        const hexStamp = Math.floor(+new Date() / 1000).toString(16);\n\n        const idLength = finalLength - 9;\n\n        const rndIdx = Math.round(Math.random() * ((idLength > 15) ? 15 : idLength));\n\n        const id = randomUUID(idLength);\n\n        return `${id.substr(0, rndIdx)}${hexStamp}${id.substr(rndIdx)}${rndIdx.toString(16)}`;\n    }\n\n    /**\n     * Extracts the date embeded in a UUID generated using the `uid.stamp(finalLength);` method.\n     *\n     * ```js\n     *  const uidWithTimestamp = uid.stamp(32);\n     *  console.log(uidWithTimestamp);\n     *  // GDa608f973aRCHLXQYPTbKDbjDeVsSb3\n     *\n     *  console.log(uid.parseStamp(uidWithTimestamp));\n     *  // 2021-05-03T06:24:58.000Z\n     *  ```\n     */\n    const parseStamp = (stamp: string): Date => {\n        if (stamp.length < 10) {\n            throw new Error('Stamp length invalid');\n        }\n\n        const rndIdx = parseInt(stamp.substr(stamp.length - 1, 1), 16)\n        return new Date(parseInt(stamp.substr(rndIdx, 8), 16) * 1000)\n    }\n\n    // Initialise\n    setDictionary(options.dictionary, options.shuffle)\n\n    return {\n        setDictionary,\n        sequentialUUID,\n        randomUUID,\n        availableUUIDs,\n        approxMaxBeforeCollision,\n        collisionProbability,\n        uniqueness,\n        getVersion,\n        stamp,\n        parseStamp\n    }\n}\n"],"names":[],"mappings":"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"}