{"version":3,"file":"short-uuid.umd.js","sources":["../src/index.ts"],"sourcesContent":["const version = \"4.4.4\"\n\n/**\n * Types\n */\n\nexport interface Options {\n    /** User-defined character dictionary */\n    dictionary: string[] | keyof typeof DICTIONNARIES;\n\n    /** If true, sequentialUUID use the dictionary in the given order */\n    shuffle: boolean;\n\n    /** If true the instance will console.log useful info */\n    debug: boolean;\n\n    /** From 1 to infinity, the length you wish your UUID to be */\n    length: number;\n}\n\ninterface State { version: string, dict: string[], counter: number }\n\n/**\n * Constants\n */\n\nconst DEFAULT_UUID_LENGTH: number = 6;\nconst BOUNDARIES = {\n    'digits': [48, 58],\n    'alpha_lower': [97,123],\n    'hex': [97, 103],\n    'alpha_upper': [65, 91]\n}\nconst DICTIONNARIES = {\n    'number': getDictionnary([BOUNDARIES['digits']]),\n    'alpha': getDictionnary([BOUNDARIES['alpha_lower'], BOUNDARIES['alpha_upper']]),\n    'alpha_lower': getDictionnary([BOUNDARIES['alpha_lower']]),\n    'alpha_upper': getDictionnary([BOUNDARIES['alpha_upper']]),\n    'alphanum': getDictionnary([BOUNDARIES['digits'], BOUNDARIES['alpha_lower'], BOUNDARIES['alpha_upper']]),\n    'alphanum_lower': getDictionnary([BOUNDARIES['digits'], BOUNDARIES['alpha_lower']]),\n    'alphanum_upper': getDictionnary([BOUNDARIES['digits'], BOUNDARIES['alpha_upper']]),\n    'hex': getDictionnary([BOUNDARIES['digits'], BOUNDARIES['hex']])\n}\nconst DEFAULT_PROBABILITY = 0.5\n\nconst DEFAULT_OPTIONS: Options = {\n    dictionary: 'alphanum',\n    shuffle: true,\n    debug: false,\n    length: DEFAULT_UUID_LENGTH,\n}\n/**\n *\n * Utils\n *\n */\nfunction getRange(from: number, to: number): number[] {\n    return [...Array(to - from).keys()].map(i => i + from)\n}\nfunction getDictionnary(definitions: number[][]): string[] {\n    const dict: string[] = []\n    for (const [lower, upper] of definitions) {\n        getRange(lower, upper).map((bound) => {\n            dict.push(String.fromCharCode(bound))\n        })\n    }\n    return dict\n}\n\nexport const ShortUUID = (_options?: Partial<Options>) => {\n    const options = { ...DEFAULT_OPTIONS, ..._options }\n    const state: State = {\n        version: version,\n        dict: [],\n        counter: 0\n    }\n\n    const setDictionary = (dictionary: string[] | keyof typeof DICTIONNARIES, shuffle?: boolean): void => {\n        let dict: string[];\n        if (dictionary && Array.isArray(dictionary)) {\n            if (dictionary.length < 1) throw Error('Please provide an array with some elements')\n            dict = dictionary as string[];\n        } else {\n            dict = [...DICTIONNARIES[dictionary]]\n        }\n\n        if (shuffle) {\n            // Shuffle Dictionary to remove selection bias.\n            dict = dict.sort(() => Math.random() - DEFAULT_PROBABILITY)\n        }\n        state.dict = dict\n        state.counter = 0\n    }\n\n    /**\n     * Generates UUID based on internal counter that's incremented after each ID generation.\n     * @alias `const uid = new ShortUniqueId(); uid.seq();`\n     */\n    const sequentialUUID = (): string => {\n        let counterDiv: number;\n        let counterRem: number;\n        let id: string = '';\n\n        counterDiv = state.counter;\n\n        do {\n            counterRem = counterDiv % state.dict.length;\n            counterDiv = Math.trunc(counterDiv / state.dict.length);\n            id += state.dict[counterRem];\n        } while (counterDiv !== 0);\n\n        state.counter += 1;\n\n        return id;\n    };\n\n    /**\n     * Generates UUID by creating each part randomly.\n     * @alias `const uid = new ShortUniqueId(); uid(uuidLength: number);`\n     */\n    const randomUUID = (uuidLength: number = options.length || DEFAULT_UUID_LENGTH): string => {\n        if ((uuidLength === null || typeof uuidLength === 'undefined') || uuidLength < 1) {\n            throw new Error('Invalid UUID Length Provided');\n        }\n\n        // Generate random ID parts from Dictionary.\n        return getRange(0, uuidLength).map(() => {\n            const randomPartIdx = parseInt(\n                (Math.random() * state.dict.length).toFixed(0),\n                10,\n            ) % state.dict.length;\n            return state.dict[randomPartIdx];\n        }).join('')\n    };\n\n    /**\n     * Calculates total number of possible UUIDs.\n     *\n     * Given that:\n     *\n     * - `H` is the total number of possible UUIDs\n     * - `n` is the number of unique characters in the dictionary\n     * - `l` is the UUID length\n     *\n     * Then `H` is defined as `n` to the power of `l`:\n     *\n     * ![](https://render.githubusercontent.com/render/math?math=%5CHuge%20H=n%5El)\n     *\n     * This function returns `H`.\n     */\n    const availableUUIDs = (uuidLength: number = options.length): number => {\n        return parseFloat(\n            Math.pow([...new Set(state.dict)].length, uuidLength).toFixed(0),\n        );\n    };\n\n    /**\n     * Calculates approximate number of hashes before first collision.\n     *\n     * Given that:\n     *\n     * - `H` is the total number of possible UUIDs, or in terms of this library,\n     * the result of running `availableUUIDs()`\n     * - the expected number of values we have to choose before finding the\n     * first collision can be expressed as the quantity `Q(H)`\n     *\n     * Then `Q(H)` can be approximated as the square root of the product of half\n     * of pi times `H`:\n     *\n     * ![](https://render.githubusercontent.com/render/math?math=%5CHuge%20Q(H)%5Capprox%5Csqrt%7B%5Cfrac%7B%5Cpi%7D%7B2%7DH%7D)\n     *\n     * This function returns `Q(H)`.\n     *\n     * (see [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution))\n     */\n    const approxMaxBeforeCollision = (rounds: number = availableUUIDs(options.length)): number => {\n        return parseFloat(\n            Math.sqrt((Math.PI / 2) * rounds).toFixed(20),\n        );\n    };\n\n    /**\n     * Calculates probability of generating duplicate UUIDs (a collision) in a\n     * given number of UUID generation rounds.\n     *\n     * Given that:\n     *\n     * - `r` is the maximum number of times that `randomUUID()` will be called,\n     * or better said the number of _rounds_\n     * - `H` is the total number of possible UUIDs, or in terms of this library,\n     * the result of running `availableUUIDs()`\n     *\n     * Then the probability of collision `p(r; H)` can be approximated as the result\n     * of dividing the square root of the product of half of pi times `r` by `H`:\n     *\n     * ![](https://render.githubusercontent.com/render/math?math=%5CHuge%20p(r%3B%20H)%5Capprox%5Cfrac%7B%5Csqrt%7B%5Cfrac%7B%5Cpi%7D%7B2%7Dr%7D%7D%7BH%7D)\n     *\n     * This function returns `p(r; H)`.\n     *\n     * (see [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution))\n     *\n     * (Useful if you are wondering _\"If I use this lib and expect to perform at most\n     * `r` rounds of UUID generations, what is the probability that I will hit a duplicate UUID?\"_.)\n     */\n    const collisionProbability = (\n        rounds: number = availableUUIDs(options.length),\n        uuidLength: number = options.length,\n    ): number => {\n        const probability = approxMaxBeforeCollision(rounds) / availableUUIDs(uuidLength)\n        return parseFloat((probability).toFixed(20))\n    }\n\n    /**\n     * Calculate a \"uniqueness\" score (from 0 to 1) of UUIDs based on size of\n     * dictionary and chosen UUID length.\n     *\n     * Given that:\n     *\n     * - `H` is the total number of possible UUIDs, or in terms of this library,\n     * the result of running `availableUUIDs()`\n     * - `Q(H)` is the approximate number of hashes before first collision,\n     * or in terms of this library, the result of running `approxMaxBeforeCollision()`\n     *\n     * Then `uniqueness` can be expressed as the additive inverse of the probability of\n     * generating a \"word\" I had previously generated (a duplicate) at any given iteration\n     * up to the the total number of possible UUIDs expressed as the quotiend of `Q(H)` and `H`:\n     *\n     * ![](https://render.githubusercontent.com/render/math?math=%5CHuge%201-%5Cfrac%7BQ(H)%7D%7BH%7D)\n     *\n     * (Useful if you need a value to rate the \"quality\" of the combination of given dictionary\n     * and UUID length. The closer to 1, higher the uniqueness and thus better the quality.)\n     */\n    const uniqueness = (rounds: number = availableUUIDs(options.length)): number => {\n        const collisionOnRounds = approxMaxBeforeCollision(rounds) / rounds\n        const score = parseFloat((1 - collisionOnRounds).toFixed(20))\n\n        if (score > 1)\n            return 1\n        if (score < 0)\n            return 0\n        return score\n    }\n\n    /**\n     * Return the version of this module.\n     */\n    const getVersion = (): string => {\n        return state.version\n    }\n\n    /**\n     * Generates a UUID with a timestamp that can be extracted using `uid.parseStamp(stampString);`.\n     *\n     * ```js\n     *  const uidWithTimestamp = uid.stamp(32);\n     *  console.log(uidWithTimestamp);\n     *  // GDa608f973aRCHLXQYPTbKDbjDeVsSb3\n     *\n     *  console.log(uid.parseStamp(uidWithTimestamp));\n     *  // 2021-05-03T06:24:58.000Z\n     *  ```\n     */\n    const stamp = (finalLength: number): string => {\n        if (typeof finalLength !== 'number' || finalLength < 10) {\n        throw new Error('Param finalLength must be number greater than 10');\n        }\n\n        const hexStamp = Math.floor(+new Date() / 1000).toString(16);\n\n        const idLength = finalLength - 9;\n\n        const rndIdx = Math.round(Math.random() * ((idLength > 15) ? 15 : idLength));\n\n        const id = randomUUID(idLength);\n\n        return `${id.substr(0, rndIdx)}${hexStamp}${id.substr(rndIdx)}${rndIdx.toString(16)}`;\n    }\n\n    /**\n     * Extracts the date embeded in a UUID generated using the `uid.stamp(finalLength);` method.\n     *\n     * ```js\n     *  const uidWithTimestamp = uid.stamp(32);\n     *  console.log(uidWithTimestamp);\n     *  // GDa608f973aRCHLXQYPTbKDbjDeVsSb3\n     *\n     *  console.log(uid.parseStamp(uidWithTimestamp));\n     *  // 2021-05-03T06:24:58.000Z\n     *  ```\n     */\n    const parseStamp = (stamp: string): Date => {\n        if (stamp.length < 10) {\n            throw new Error('Stamp length invalid');\n        }\n\n        const rndIdx = parseInt(stamp.substr(stamp.length - 1, 1), 16)\n        return new Date(parseInt(stamp.substr(rndIdx, 8), 16) * 1000)\n    }\n\n    // Initialise\n    setDictionary(options.dictionary, options.shuffle)\n\n    return {\n        setDictionary,\n        sequentialUUID,\n        randomUUID,\n        availableUUIDs,\n        approxMaxBeforeCollision,\n        collisionProbability,\n        uniqueness,\n        getVersion,\n        stamp,\n        parseStamp\n    }\n}\n"],"names":[],"mappings":";;;;;;IAAA,MAAM,OAAO,GAAG,OAAO,CAAA;IAsBvB;;IAEG;IAEH,MAAM,mBAAmB,GAAW,CAAC,CAAC;IACtC,MAAM,UAAU,GAAG;IACf,IAAA,QAAQ,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;IAClB,IAAA,aAAa,EAAE,CAAC,EAAE,EAAC,GAAG,CAAC;IACvB,IAAA,KAAK,EAAE,CAAC,EAAE,EAAE,GAAG,CAAC;IAChB,IAAA,aAAa,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;KAC1B,CAAA;IACD,MAAM,aAAa,GAAG;QAClB,QAAQ,EAAE,cAAc,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC;IAChD,IAAA,OAAO,EAAE,cAAc,CAAC,CAAC,UAAU,CAAC,aAAa,CAAC,EAAE,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC;QAC/E,aAAa,EAAE,cAAc,CAAC,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC;QAC1D,aAAa,EAAE,cAAc,CAAC,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC;IAC1D,IAAA,UAAU,EAAE,cAAc,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE,UAAU,CAAC,aAAa,CAAC,EAAE,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC;IACxG,IAAA,gBAAgB,EAAE,cAAc,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC;IACnF,IAAA,gBAAgB,EAAE,cAAc,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC;IACnF,IAAA,KAAK,EAAE,cAAc,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;KACnE,CAAA;IACD,MAAM,mBAAmB,GAAG,GAAG,CAAA;IAE/B,MAAM,eAAe,GAAY;IAC7B,IAAA,UAAU,EAAE,UAAU;IACtB,IAAA,OAAO,EAAE,IAAI;IACb,IAAA,KAAK,EAAE,KAAK;IACZ,IAAA,MAAM,EAAE,mBAAmB;KAC9B,CAAA;IACD;;;;IAIG;IACH,SAAS,QAAQ,CAAC,IAAY,EAAE,EAAU,EAAA;QACtC,OAAO,CAAC,GAAG,KAAK,CAAC,EAAE,GAAG,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,CAAA;IAC1D,CAAC;IACD,SAAS,cAAc,CAAC,WAAuB,EAAA;QAC3C,MAAM,IAAI,GAAa,EAAE,CAAA;QACzB,KAAK,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,IAAI,WAAW,EAAE;YACtC,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,KAAI;gBACjC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAA;IACzC,SAAC,CAAC,CAAA;IACL,KAAA;IACD,IAAA,OAAO,IAAI,CAAA;IACf,CAAC;AAEY,UAAA,SAAS,GAAG,CAAC,QAA2B,KAAI;IACrD,IAAA,MAAM,OAAO,GAAQ,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAA,eAAe,CAAK,EAAA,QAAQ,CAAE,CAAA;IACnD,IAAA,MAAM,KAAK,GAAU;IACjB,QAAA,OAAO,EAAE,OAAO;IAChB,QAAA,IAAI,EAAE,EAAE;IACR,QAAA,OAAO,EAAE,CAAC;SACb,CAAA;IAED,IAAA,MAAM,aAAa,GAAG,CAAC,UAAiD,EAAE,OAAiB,KAAU;IACjG,QAAA,IAAI,IAAc,CAAC;YACnB,IAAI,UAAU,IAAI,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;IACzC,YAAA,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC;IAAE,gBAAA,MAAM,KAAK,CAAC,4CAA4C,CAAC,CAAA;gBACpF,IAAI,GAAG,UAAsB,CAAC;IACjC,SAAA;IAAM,aAAA;gBACH,IAAI,GAAG,CAAC,GAAG,aAAa,CAAC,UAAU,CAAC,CAAC,CAAA;IACxC,SAAA;IAED,QAAA,IAAI,OAAO,EAAE;;IAET,YAAA,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,EAAE,GAAG,mBAAmB,CAAC,CAAA;IAC9D,SAAA;IACD,QAAA,KAAK,CAAC,IAAI,GAAG,IAAI,CAAA;IACjB,QAAA,KAAK,CAAC,OAAO,GAAG,CAAC,CAAA;IACrB,KAAC,CAAA;IAED;;;IAGG;QACH,MAAM,cAAc,GAAG,MAAa;IAChC,QAAA,IAAI,UAAkB,CAAC;IACvB,QAAA,IAAI,UAAkB,CAAC;YACvB,IAAI,EAAE,GAAW,EAAE,CAAC;IAEpB,QAAA,UAAU,GAAG,KAAK,CAAC,OAAO,CAAC;YAE3B,GAAG;gBACC,UAAU,GAAG,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC;IAC5C,YAAA,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACxD,YAAA,EAAE,IAAI,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;aAChC,QAAQ,UAAU,KAAK,CAAC,EAAE;IAE3B,QAAA,KAAK,CAAC,OAAO,IAAI,CAAC,CAAC;IAEnB,QAAA,OAAO,EAAE,CAAC;IACd,KAAC,CAAC;IAEF;;;IAGG;QACH,MAAM,UAAU,GAAG,CAAC,UAAqB,GAAA,OAAO,CAAC,MAAM,IAAI,mBAAmB,KAAY;IACtF,QAAA,IAAI,CAAC,UAAU,KAAK,IAAI,IAAI,OAAO,UAAU,KAAK,WAAW,KAAK,UAAU,GAAG,CAAC,EAAE;IAC9E,YAAA,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;IACnD,SAAA;;YAGD,OAAO,QAAQ,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC,GAAG,CAAC,MAAK;IACpC,YAAA,MAAM,aAAa,GAAG,QAAQ,CAC1B,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC,EAC9C,EAAE,CACL,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC;IACtB,YAAA,OAAO,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;IACrC,SAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;IACf,KAAC,CAAC;IAEF;;;;;;;;;;;;;;IAcG;QACH,MAAM,cAAc,GAAG,CAAC,UAAA,GAAqB,OAAO,CAAC,MAAM,KAAY;YACnE,OAAO,UAAU,CACb,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CACnE,CAAC;IACN,KAAC,CAAC;IAEF;;;;;;;;;;;;;;;;;;IAkBG;QACH,MAAM,wBAAwB,GAAG,CAAC,MAAiB,GAAA,cAAc,CAAC,OAAO,CAAC,MAAM,CAAC,KAAY;YACzF,OAAO,UAAU,CACb,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,IAAI,MAAM,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC,CAChD,CAAC;IACN,KAAC,CAAC;IAEF;;;;;;;;;;;;;;;;;;;;;;IAsBG;IACH,IAAA,MAAM,oBAAoB,GAAG,CACzB,MAAiB,GAAA,cAAc,CAAC,OAAO,CAAC,MAAM,CAAC,EAC/C,UAAqB,GAAA,OAAO,CAAC,MAAM,KAC3B;YACR,MAAM,WAAW,GAAG,wBAAwB,CAAC,MAAM,CAAC,GAAG,cAAc,CAAC,UAAU,CAAC,CAAA;YACjF,OAAO,UAAU,CAAC,CAAC,WAAW,EAAE,OAAO,CAAC,EAAE,CAAC,CAAC,CAAA;IAChD,KAAC,CAAA;IAED;;;;;;;;;;;;;;;;;;;IAmBG;QACH,MAAM,UAAU,GAAG,CAAC,MAAiB,GAAA,cAAc,CAAC,OAAO,CAAC,MAAM,CAAC,KAAY;YAC3E,MAAM,iBAAiB,GAAG,wBAAwB,CAAC,MAAM,CAAC,GAAG,MAAM,CAAA;IACnE,QAAA,MAAM,KAAK,GAAG,UAAU,CAAC,CAAC,CAAC,GAAG,iBAAiB,EAAE,OAAO,CAAC,EAAE,CAAC,CAAC,CAAA;YAE7D,IAAI,KAAK,GAAG,CAAC;IACT,YAAA,OAAO,CAAC,CAAA;YACZ,IAAI,KAAK,GAAG,CAAC;IACT,YAAA,OAAO,CAAC,CAAA;IACZ,QAAA,OAAO,KAAK,CAAA;IAChB,KAAC,CAAA;IAED;;IAEG;QACH,MAAM,UAAU,GAAG,MAAa;YAC5B,OAAO,KAAK,CAAC,OAAO,CAAA;IACxB,KAAC,CAAA;IAED;;;;;;;;;;;IAWG;IACH,IAAA,MAAM,KAAK,GAAG,CAAC,WAAmB,KAAY;YAC1C,IAAI,OAAO,WAAW,KAAK,QAAQ,IAAI,WAAW,GAAG,EAAE,EAAE;IACzD,YAAA,MAAM,IAAI,KAAK,CAAC,kDAAkD,CAAC,CAAC;IACnE,SAAA;IAED,QAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,IAAI,EAAE,GAAG,IAAI,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;IAE7D,QAAA,MAAM,QAAQ,GAAG,WAAW,GAAG,CAAC,CAAC;YAEjC,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,QAAQ,GAAG,EAAE,IAAI,EAAE,GAAG,QAAQ,CAAC,CAAC,CAAC;IAE7E,QAAA,MAAM,EAAE,GAAG,UAAU,CAAC,QAAQ,CAAC,CAAC;YAEhC,OAAO,CAAA,EAAG,EAAE,CAAC,MAAM,CAAC,CAAC,EAAE,MAAM,CAAC,CAAG,EAAA,QAAQ,CAAG,EAAA,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,CAAG,EAAA,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAA,CAAE,CAAC;IAC1F,KAAC,CAAA;IAED;;;;;;;;;;;IAWG;IACH,IAAA,MAAM,UAAU,GAAG,CAAC,KAAa,KAAU;IACvC,QAAA,IAAI,KAAK,CAAC,MAAM,GAAG,EAAE,EAAE;IACnB,YAAA,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC;IAC3C,SAAA;IAED,QAAA,MAAM,MAAM,GAAG,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAA;IAC9D,QAAA,OAAO,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,IAAI,CAAC,CAAA;IACjE,KAAC,CAAA;;QAGD,aAAa,CAAC,OAAO,CAAC,UAAU,EAAE,OAAO,CAAC,OAAO,CAAC,CAAA;QAElD,OAAO;YACH,aAAa;YACb,cAAc;YACd,UAAU;YACV,cAAc;YACd,wBAAwB;YACxB,oBAAoB;YACpB,UAAU;YACV,UAAU;YACV,KAAK;YACL,UAAU;SACb,CAAA;IACL;;;;;;;;"}